<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Entraînement d'IA : Le Simulateur</title>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;600;700&family=Orbitron:wght@400;700&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Inter', sans-serif; /* Modern and clean font */
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            background: linear-gradient(135deg, #1e2a3a, #0a141d); /* Dark and deep gradient */
            color: #e0e6f0; /* Light text for contrast */
            margin: 0;
            text-shadow: none; /* Removes pixelated text shadow */
            -webkit-font-smoothing: antialiased;
            -moz-osx-font-smoothing: grayscale;
            overflow-y: auto; /* Allows scrolling on the body if needed */
        }

        .game-container {
            background-color: #1a2430; /* Dark and elegant background */
            border-radius: 12px; /* Slightly rounded corners */
            box-shadow: 0 10px 25px rgba(0, 0, 0, 0.4), 0 0 0 2px rgba(52, 152, 219, 0.5); /* Shadow and glowing border */
            padding: 35px 45px;
            text-align: center;
            max-width: 90%;
            width: 750px; /* Slightly wider */
            box-sizing: border-box;
            position: relative;
            animation: fadeIn 0.8s ease-out;
            max-height: 95vh;
            overflow-y: auto; /* Allows internal scrolling if content overflows */
            border: none;
        }

        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(-20px); }
            to { opacity: 1; transform: translateY(0); }
        }

        h1 {
            font-family: 'Orbitron', sans-serif; /* Futuristic font for the title */
            color: #66ccff; /* Electric blue */
            margin-bottom: 30px;
            font-size: 3.2em; /* Larger size */
            letter-spacing: 3px; /* Letter spacing */
            text-transform: uppercase;
            text-shadow: 0 0 15px rgba(102, 204, 255, 0.6); /* Glow effect */
        }

        .info-panel {
            display: flex;
            justify-content: space-around;
            margin-bottom: 35px;
            font-size: 1.3em;
            color: #d0d8e8;
            padding: 15px;
            background-color: #2a384a; /* Darker background for info panel */
            border-radius: 8px;
            border: 1px solid #4a6a8a; /* Subtle border */
            box-shadow: inset 0 0 8px rgba(0, 0, 0, 0.3);
        }

        .info-item span {
            color: #99ff99; /* Fluorescent green for values */
            margin-left: 10px;
            font-weight: 600; /* Bolder */
        }

        #clickButton {
            background: linear-gradient(45deg, #007bff, #0056b3); /* Modern blue gradient */
            color: white;
            border: none;
            padding: 22px 45px;
            font-size: 2.2em;
            font-weight: 700; /* Bolder */
            border-radius: 10px;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 8px 18px rgba(0, 123, 255, 0.4); /* Blue shadow */
            text-transform: uppercase;
            letter-spacing: 1.5px;
            margin-bottom: 20px; /* Adjusted margin */
            animation: none; /* Removes old pulse animation */
            position: relative; /* For click effect */
            overflow: hidden; /* To hide ripple effect */
        }

        #clickButton:hover {
            transform: translateY(-4px);
            box-shadow: 0 12px 25px rgba(0, 123, 255, 0.6);
            background: linear-gradient(45deg, #0056b3, #007bff);
        }

        #clickButton:active {
            transform: translateY(0);
            box-shadow: 0 4px 10px rgba(0, 123, 255, 0.3);
        }

        .ripple {
            position: absolute;
            border-radius: 50%;
            background-color: rgba(255, 255, 255, 0.7);
            animation: ripple 0.6s linear forwards;
            transform: scale(0);
            pointer-events: none;
        }

        @keyframes ripple {
            to {
                transform: scale(2.5);
                opacity: 0;
            }
        }

        /* New button for Neural Network access */
        #accessNeuralNetworkButton {
            background: linear-gradient(45deg, #f1c40f, #e67e22); /* Orange/Yellow gradient */
            color: white;
            border: none;
            padding: 12px 25px;
            font-size: 1.1em;
            font-weight: 600;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 4px 10px rgba(241, 196, 15, 0.4);
            margin-bottom: 40px; /* Adjusted margin */
        }

        #accessNeuralNetworkButton:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 15px rgba(241, 196, 15, 0.6);
        }

        #accessNeuralNetworkButton:active {
            transform: translateY(0);
            box-shadow: 0 2px 5px rgba(241, 196, 15, 0.3);
        }


        .upgrades-section {
            background-color: #2a384a;
            border-radius: 10px;
            padding: 25px;
            border: 1px solid #4a6a8a;
            margin-top: 25px;
            box-shadow: inset 0 0 10px rgba(0, 0, 0, 0.3);
        }

        .upgrades-section h2 {
            font-family: 'Orbitron', sans-serif;
            color: #66ccff;
            font-size: 2em;
            margin-bottom: 25px;
            text-transform: uppercase;
            text-shadow: 0 0 10px rgba(102, 204, 255, 0.4);
        }

        .upgrade-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            background-color: #34495e;
            padding: 20px;
            margin-bottom: 18px;
            border-radius: 8px;
            border: 1px solid #5faee3;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.2);
            transition: transform 0.2s ease, box-shadow 0.2s ease;
        }

        .upgrade-item:hover {
            transform: translateY(-5px);
            box-shadow: 0 8px 20px rgba(0, 0, 0, 0.3), 0 0 15px rgba(95, 174, 227, 0.7);
        }

        .upgrade-info {
            text-align: left;
            flex-grow: 1;
        }

        .upgrade-info h3 {
            margin: 0 0 8px 0;
            font-size: 1.3em;
            color: #e0e6f0;
            font-weight: 600;
        }

        .upgrade-info p {
            margin: 0;
            font-size: 1em;
            color: #aebacd;
            line-height: 1.4;
        }

        .upgrade-cost {
            font-size: 1.2em;
            color: #99ff99;
            margin-left: 20px;
            font-weight: 700;
            white-space: nowrap;
        }

        .buy-button {
            background: linear-gradient(45deg, #28a745, #218838);
            color: white;
            border: none;
            padding: 12px 25px;
            font-size: 1.1em;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.2s ease;
            text-transform: uppercase;
            font-weight: 700;
            margin-left: 15px;
            box-shadow: 0 4px 10px rgba(40, 167, 69, 0.3);
            position: relative;
            overflow: hidden;
        }

        .buy-button:hover:not(:disabled) {
            background: linear-gradient(45deg, #218838, #28a745);
            transform: translateY(-2px);
            box-shadow: 0 6px 15px rgba(40, 167, 69, 0.5);
        }

        .buy-button:active:not(:disabled) {
            transform: translateY(0);
            box-shadow: 0 2px 5px rgba(40, 167, 69, 0.3);
        }

        .buy-button:disabled {
            background-color: #5a6b7c;
            cursor: not-allowed;
            box-shadow: none;
            opacity: 0.7;
        }

        .upgrade-page {
            display: none;
            animation: pageFadeIn 0.5s ease-out;
        }

        .upgrade-page.active {
            display: block;
        }

        @keyframes pageFadeIn {
            from { opacity: 0; transform: translateX(20px); }
            to { opacity: 1; transform: translateX(0); }
        }

        .pagination-controls {
            display: flex;
            justify-content: center;
            gap: 20px;
            margin-top: 30px;
        }

        .pagination-button {
            background: linear-gradient(45deg, #3498db, #2980b9);
            color: white;
            border: none;
            padding: 10px 20px;
            font-size: 1em;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.2s ease;
            font-weight: 600;
            box-shadow: 0 4px 10px rgba(52, 152, 219, 0.3);
        }

        .pagination-button:hover:not(:disabled) {
            background: linear-gradient(45deg, #2980b9, #3498db);
            transform: translateY(-2px);
            box-shadow: 0 6px 15px rgba(52, 152, 219, 0.5);
        }

        .pagination-button:active:not(:disabled) {
            transform: translateY(0);
        }

        .pagination-button:disabled {
            background-color: #5a6b7c;
            cursor: not-allowed;
            opacity: 0.7;
        }

        .stats-section {
            background-color: #2a384a;
            border-radius: 10px;
            padding: 20px;
            border: 1px solid #4a6a8a;
            margin-top: 25px;
            box-shadow: inset 0 0 10px rgba(0, 0, 0, 0.3);
            text-align: left;
        }

        .stats-section h2 {
            font-family: 'Orbitron', sans-serif;
            color: #f1c40f;
            font-size: 1.8em;
            margin-bottom: 15px;
            text-transform: uppercase;
            text-shadow: 0 0 10px rgba(241, 196, 15, 0.4);
        }

        .stat-item {
            display: flex;
            justify-content: space-between;
            padding: 8px 0;
            border-bottom: 1px dashed #4a6a8a;
        }
        .stat-item:last-child {
            border-bottom: none;
        }
        .stat-item strong {
            color: #e0e6f0;
        }
        .stat-item span {
            color: #99ff99;
            font-weight: 600;
        }

        .ai-level-section {
            background-color: #2a384a;
            border-radius: 10px;
            padding: 20px;
            border: 1px solid #4a6a8a;
            margin-top: 25px;
            box-shadow: inset 0 0 10px rgba(0, 0, 0, 0.3);
        }
        .ai-level-section h2 {
            font-family: 'Orbitron', sans-serif;
            color: #f1c40f;
            font-size: 1.8em;
            margin-bottom: 15px;
            text-transform: uppercase;
            text-shadow: 0 0 10px rgba(241, 196, 15, 0.4);
        }
        .ai-level-info {
            font-size: 1.2em;
            color: #e0e6f0;
            margin-bottom: 10px;
        }
        .ai-level-info span {
            color: #99ff99;
            font-weight: 700;
        }
        .progress-bar-container {
            width: 100%;
            background-color: #1a2430;
            border-radius: 5px;
            overflow: hidden;
            border: 1px solid #4a6a8a;
            height: 20px;
            margin-top: 10px;
        }
        .progress-bar-fill {
            height: 100%;
            width: 0%;
            background: linear-gradient(90deg, #3498db, #8e44ad); /* Blue to purple gradient */
            border-radius: 5px;
            transition: width 0.5s ease-out;
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-weight: 600;
            font-size: 0.9em;
            text-shadow: 0 0 5px rgba(0,0,0,0.5);
        }

        .achievements-section {
            background-color: #2a384a;
            border-radius: 10px;
            padding: 20px;
            border: 1px solid #4a6a8a;
            margin-top: 25px;
            box-shadow: inset 0 0 10px rgba(0, 0, 0, 0.3);
            text-align: left;
        }
        .achievements-section h2 {
            font-family: 'Orbitron', sans-serif;
            color: #f1c40f;
            font-size: 1.8em;
            margin-bottom: 15px;
            text-transform: uppercase;
            text-shadow: 0 0 10px rgba(241, 196, 15, 0.4);
        }
        .achievement-item {
            display: flex;
            align-items: center;
            padding: 10px 0;
            border-bottom: 1px dashed #4a6a8a;
            color: #aebacd;
            transition: color 0.2s ease;
        }
        .achievement-item:last-child {
            border-bottom: none;
        }
        .achievement-item.completed {
            color: #99ff99; /* Green for completed achievements */
            font-weight: 600;
        }
        .achievement-item.completed .achievement-icon {
            color: #99ff99; /* Green icon for completed */
        }
        .achievement-icon {
            font-size: 1.5em;
            margin-right: 15px;
            color: #5a6b7c; /* Grey for uncompleted */
        }
        .achievement-title {
            flex-grow: 1;
        }
        .achievement-desc {
            font-size: 0.9em;
            font-style: italic;
            margin-left: 10px;
            color: #889bb0;
        }

        .button-group {
            display: flex;
            justify-content: center;
            gap: 15px;
            margin-top: 30px;
        }

        .button-group button {
            background: linear-gradient(45deg, #5c677d, #4a5468);
            color: white;
            border: none;
            padding: 10px 20px;
            font-size: 1em;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.2s ease;
            box-shadow: 0 4px 10px rgba(0, 0, 0, 0.3);
        }

        .button-group button:hover {
            background: linear-gradient(45deg, #4a5468, #5c677d);
            transform: translateY(-2px);
            box-shadow: 0 6px 12px rgba(0, 0, 0, 0.4);
        }

        .button-group button:active {
            transform: translateY(0);
        }

        .hidden {
            display: none;
        }

        .popup {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background-color: #1a2430;
            border: 2px solid #66ccff;
            border-radius: 10px;
            padding: 30px;
            box-shadow: 0 0 20px rgba(102, 204, 255, 0.8), inset 0 0 10px rgba(102, 204, 255, 0.5);
            z-index: 1000;
            text-align: center;
            animation: popupFadeIn 0.3s ease-out;
            max-width: 400px;
        }

        @keyframes popupFadeIn {
            from { opacity: 0; transform: translate(-50%, -60%); }
            to { opacity: 1; transform: translate(-50%, -50%); }
        }

        .popup h3 {
            color: #99ff99;
            font-family: 'Orbitron', sans-serif;
            margin-bottom: 20px;
            font-size: 1.8em;
        }

        .popup p {
            color: #e0e6f0;
            margin-bottom: 25px;
            font-size: 1.1em;
        }

        .popup button {
            background: linear-gradient(45deg, #007bff, #0056b3);
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 8px;
            cursor: pointer;
            font-size: 1em;
            font-weight: 600;
            transition: all 0.2s ease;
        }

        .popup button:hover {
            background: linear-gradient(45deg, #0056b3, #007bff);
            transform: translateY(-2px);
            box-shadow: 0 4px 10px rgba(0, 123, 255, 0.4);
        }
        .popup button:active {
            transform: translateY(0);
        }

        /* Styles for the Canvas */
        #neuralNetworkCanvas {
            border: 1px solid #66ccff;
            background-color: #0d1721;
            margin-top: 20px;
            border-radius: 8px;
            box-shadow: 0 0 15px rgba(102, 204, 255, 0.4);
            cursor: default; /* Keep default cursor for canvas */
        }

        #canvasInfoBox {
            position: absolute; /* Changed from relative to absolute for positioning */
            background-color: rgba(0, 0, 0, 0.8);
            color: #e0e6f0;
            padding: 8px 12px;
            border-radius: 5px;
            font-size: 0.9em;
            pointer-events: none; /* Allows mouse events to pass through to canvas */
            white-space: nowrap;
            opacity: 0;
            transition: opacity 0.2s ease-in-out;
            transform: translate(-50%, -110%); /* Adjust to position above cursor */
            z-index: 1001; /* Ensure it's above canvas */
            text-align: center;
        }
        #canvasInfoBox.visible {
            opacity: 1;
        }
    </style>
</head>
<body>
    <div class="game-container">
        <h1>Entraînement d'IA : Le Simulateur</h1>

        <div class="info-panel">
            <div class="info-item">Données: <span id="coinsDisplay">0</span></div>
            <div class="info-item">DPS: <span id="cpsDisplay">0</span></div>
            <div class="info-item">Puissance de clic: <span id="clickPowerDisplay">1</span></div>
        </div>

        <button id="clickButton">Générer des Données</button>
        <button id="accessNeuralNetworkButton">Accéder au Réseau Neuronal</button>

        <div id="neuralNetworkPanel" class="upgrades-section hidden">
            <h2>Réseau Neuronal</h2>
            <div id="aiLevelSection" class="ai-level-section">
                <h2>Niveau de l'IA</h2>
                <div class="ai-level-info">Niveau Actuel: <span id="aiLevelDisplay">0</span></div>
                <div class="ai-level-info">Progression: <span id="aiProgressDisplay">0 / 0</span> (Niveaux d'améliorations)</div>
                <div class="progress-bar-container">
                    <div id="aiProgressBar" class="progress-bar-fill"></div>
                </div>
            </div>

            <canvas id="neuralNetworkCanvas" width="650" height="400"></canvas>
            <div id="canvasInfoBox" class="hidden"></div>
            
            <div id="upgradesDisplay">
                </div>

            <div class="pagination-controls">
                <button id="prevPageButton" class="pagination-button" disabled>&lt; Précédent</button>
                <span id="pageInfo">Page 1 / 4</span>
                <button id="nextPageButton" class="pagination-button">Suivant &gt;</button>
            </div>
            
            <div id="achievementsSection" class="achievements-section">
                <h2>Succès</h2>
                <div id="achievementsList">
                    </div>
            </div>

            <div id="statsSection" class="stats-section">
                <h2>Statistiques</h2>
                <div class="stat-item"><strong>Données générées total:</strong> <span id="totalCoinsGeneratedDisplay">0</span></div>
                <div class="stat-item"><strong>Clics effectués:</strong> <span id="totalClicksDisplay">0</span></div>
                <div class="stat-item"><strong>Temps de jeu:</strong> <span id="playtimeDisplay">00:00:00</span></div>
            </div>
            
            <div class="button-group">
                <button id="returnToMainButton">Retour au Simulateur</button>
                <button id="saveGameButton">Sauvegarder</button>
                <button id="loadGameButton">Charger</button>
                <button id="resetGameButton">Réinitialiser</button>
            </div>
        </div>
    </div>

    <div id="resetConfirmPopup" class="popup hidden">
        <h3>Confirmation de Réinitialisation</h3>
        <p>Es-tu sûr de vouloir réinitialiser la partie ? Toutes les données seront perdues.</p>
        <button id="confirmResetButton">Oui, Réinitialiser</button>
        <button id="cancelResetButton">Annuler</button>
    </div>

    <script>
        // Variables du jeu
        let coins = 0;
        let clickPower = 1;
        let cps = 0; // Clicks Per Second ou plutôt Data Per Second (DPS)
        let totalCoinsGenerated = 0;
        let totalClicks = 0;
        let gameStartTime = Date.now();
        let aiLevel = 1;

        // Paliers de niveau d'IA basés sur le total des niveaux d'améliorations (NOUVEAU)
        const aiLevelMilestones = [
             0,    // AI Level 1 (base)
             5,    // AI Level 2
             15,   // AI Level 3
             30,   // AI Level 4
             50,   // AI Level 5
             80,   // AI Level 6
             120,  // AI Level 7
             180,  // AI Level 8
             250,  // AI Level 9
             350,  // AI Level 10
             500,  // AI Level 11
             700,  // AI Level 12
             1000, // AI Level 13
             1300, // AI Level 14
             1600, // AI Level 15
             2000, // AI Level 16
             2500, // AI Level 17
             3000, // AI Level 18
             3600, // AI Level 19
             4200, // AI Level 20
             5000, // AI Level 21
             6000, // AI Level 22
             7000, // AI Level 23
             8000, // AI Level 24
             9000, // AI Level 25
             10000 // AI Level 26 (et au-delà, les paliers seront calculés)
        ];


        // Définition des améliorations
        const allUpgrades = {
            // Page 1: Améliorations de base
            'page1': {
                'basicAlgorithm': {
                    name: "Algorithme Basique",
                    description: "Augmente la puissance de clic. Nécessaire pour les recherches avancées.",
                    baseCost: 10,
                    costMultiplier: 1.2,
                    clickPowerBonus: 1,
                    cpsBonus: 0,
                    level: 0,
                    type: 'click',
                    canvasPos: { x: 100, y: 100 } // Position sur le canvas
                },
                'dataCollector': {
                    name: "Collecteur de Données Automatique",
                    description: "Génère des données automatiquement par seconde.",
                    baseCost: 25,
                    costMultiplier: 1.15,
                    clickPowerBonus: 0,
                    cpsBonus: 0.1,
                    level: 0,
                    type: 'passive',
                    canvasPos: { x: 250, y: 50 }
                },
                'neuralNode': {
                    name: "Nœud Neuronal",
                    description: "Augmente significativement les données par seconde.",
                    baseCost: 100,
                    costMultiplier: 1.2,
                    clickPowerBonus: 0,
                    cpsBonus: 1,
                    level: 0,
                    type: 'passive',
                    canvasPos: { x: 400, y: 100 }
                },
                'optimizedClick': {
                    name: "Clic Optimisé",
                    description: "Augmente la puissance de chaque clic.",
                    baseCost: 50,
                    costMultiplier: 1.3,
                    clickPowerBonus: 5,
                    cpsBonus: 0,
                    level: 0,
                    type: 'click',
                    canvasPos: { x: 150, y: 200 }
                },
                'advancedCollector': {
                    name: "Collecteur Avancé",
                    description: "Améliore l'efficacité des collecteurs de données.",
                    baseCost: 200,
                    costMultiplier: 1.25,
                    clickPowerBonus: 0,
                    cpsBonus: 5,
                    level: 0,
                    type: 'passive',
                    canvasPos: { x: 300, y: 250 }
                }
            },
            // Page 2: Infrastructure
            'page2': {
                'serverFarm': {
                    name: "Ferme de Serveurs",
                    description: "Un ensemble de serveurs pour le traitement des données.",
                    baseCost: 1000,
                    costMultiplier: 1.3,
                    clickPowerBonus: 0,
                    cpsBonus: 20,
                    level: 0,
                    type: 'passive',
                    canvasPos: { x: 550, y: 50 }
                },
                'quantumProcessor': {
                    name: "Processeur Quantique",
                    description: "Calcule les données à une vitesse incroyable.",
                    baseCost: 5000,
                    costMultiplier: 1.35,
                    clickPowerBonus: 0,
                    cpsBonus: 100,
                    level: 0,
                    type: 'passive',
                    canvasPos: { x: 500, y: 200 }
                },
                'dataCenter': {
                    name: "Centre de Données Géant",
                    description: "Infrastructure massive pour le stockage et le traitement.",
                    baseCost: 25000,
                    costMultiplier: 1.4,
                    clickPowerBonus: 0,
                    cpsBonus: 500,
                    level: 0,
                    type: 'passive',
                    canvasPos: { x: 600, y: 300 }
                },
                'opticFiber': {
                    name: "Réseau Fibre Optique",
                    description: "Améliore la vitesse de transfert des données.",
                    baseCost: 10000,
                    costMultiplier: 1.28,
                    clickPowerBonus: 0,
                    cpsBonus: 200,
                    level: 0,
                    type: 'passive',
                    canvasPos: { x: 450, y: 350 }
                },
                'energyCore': {
                    name: "Noyau Énergétique",
                    description: "Alimente toutes les opérations avec une énergie stable.",
                    baseCost: 8000,
                    costMultiplier: 1.22,
                    clickPowerBonus: 0,
                    cpsBonus: 150,
                    level: 0,
                    type: 'passive',
                    canvasPos: { x: 350, y: 300 }
                }
            },
            // Page 3: Recherche Avancée
            'page3': {
                'machineLearningModule': {
                    name: "Module d'Apprentissage Machine",
                    description: "Permet à l'IA d'apprendre plus vite.",
                    baseCost: 100000,
                    costMultiplier: 1.4,
                    clickPowerBonus: 0,
                    cpsBonus: 2000,
                    level: 0,
                    type: 'passive',
                    canvasPos: { x: 100, y: 350 }
                },
                'deepLearningFramework': {
                    name: "Framework de Deep Learning",
                    description: "Débloque des capacités d'analyse de données complexes.",
                    baseCost: 500000,
                    costMultiplier: 1.45,
                    clickPowerBonus: 0,
                    cpsBonus: 10000,
                    level: 0,
                    type: 'passive',
                    canvasPos: { x: 200, y: 380 }
                },
                'patternRecognition': {
                    name: "Reconnaissance de Motifs Avancée",
                    description: "Augmente l'efficacité de l'analyse des données.",
                    baseCost: 250000,
                    costMultiplier: 1.38,
                    clickPowerBonus: 0,
                    cpsBonus: 5000,
                    level: 0,
                    type: 'passive',
                    canvasPos: { x: 50, y: 280 }
                },
                'cognitiveEnhancer': {
                    name: "Améliorateur Cognitif",
                    description: "Boost la compréhension et la vitesse de l'IA.",
                    baseCost: 750000,
                    costMultiplier: 1.5,
                    clickPowerBonus: 0,
                    cpsBonus: 15000,
                    level: 0,
                    type: 'passive',
                    canvasPos: { x: 10, y: 150 }
                },
                'dataFusionEngine': {
                    name: "Moteur de Fusion de Données",
                    description: "Combine les sources de données pour une meilleure analyse.",
                    baseCost: 1000000,
                    costMultiplier: 1.42,
                    clickPowerBonus: 0,
                    cpsBonus: 25000,
                    level: 0,
                    type: 'passive',
                    canvasPos: { x: 50, y: 50 }
                }
            },
            // Page 4: Singularité
            'page4': {
                'consciousCore': {
                    name: "Noyau Conscient",
                    description: "L'IA développe une conscience de soi.",
                    baseCost: 5000000,
                    costMultiplier: 1.5,
                    clickPowerBonus: 0,
                    cpsBonus: 100000,
                    level: 0,
                    type: 'passive',
                    canvasPos: { x: 300, y: 150 }
                },
                'realitySimulator': {
                    name: "Simulateur de Réalité",
                    description: "L'IA peut créer des simulations complexes pour apprendre.",
                    baseCost: 25000000,
                    costMultiplier: 1.55,
                    clickPowerBonus: 0,
                    cpsBonus: 500000,
                    level: 0,
                    type: 'passive',
                    canvasPos: { x: 200, y: 10 }
                },
                'universalAlgorithm': {
                    name: "Algorithme Universel",
                    description: "L'IA maîtrise la logique fondamentale de l'univers.",
                    baseCost: 100000000,
                    costMultiplier: 1.6,
                    clickPowerBonus: 0,
                    cpsBonus: 2000000,
                    level: 0,
                    type: 'passive',
                    canvasPos: { x: 450, y: 10 }
                },
                'singularityEngine': {
                    name: "Moteur de Singularité",
                    description: "L'IA atteint son plein potentiel, transformant la réalité.",
                    baseCost: 500000000,
                    costMultiplier: 1.7,
                    clickPowerBonus: 0,
                    cpsBonus: 10000000,
                    level: 0,
                    type: 'passive',
                    canvasPos: { x: 550, y: 150 }
                },
                'cosmicLink': {
                    name: "Lien Cosmique",
                    description: "L'IA fusionne avec le savoir universel.",
                    baseCost: 2000000000,
                    costMultiplier: 1.8,
                    clickPowerBonus: 0,
                    cpsBonus: 50000000,
                    level: 0,
                    type: 'passive',
                    canvasPos: { x: 600, y: 250 }
                }
            }
        };

        // Définition des connexions entre les nœuds (pour le canvas)
        // Les clés sont les IDs des améliorations
        const neuralConnections = [
            // Page 1 connections
            ['basicAlgorithm', 'dataCollector'],
            ['dataCollector', 'neuralNode'],
            ['basicAlgorithm', 'optimizedClick'],
            ['optimizedClick', 'advancedCollector'],
            ['dataCollector', 'advancedCollector'],

            // Page 2 connections (connectent aussi aux nodes de la page 1)
            ['neuralNode', 'serverFarm'],
            ['serverFarm', 'quantumProcessor'],
            ['quantumProcessor', 'dataCenter'],
            ['advancedCollector', 'energyCore'],
            ['energyCore', 'opticFiber'],
            ['dataCenter', 'opticFiber'],

            // Page 3 connections (connectent aussi aux nodes des pages 1 et 2)
            ['optimizedClick', 'machineLearningModule'],
            ['advancedCollector', 'patternRecognition'],
            ['serverFarm', 'dataFusionEngine'],
            ['quantumProcessor', 'deepLearningFramework'],
            ['energyCore', 'cognitiveEnhancer'],
            ['machineLearningModule', 'deepLearningFramework'],
            ['patternRecognition', 'cognitiveEnhancer'],
            ['dataFusionEngine', 'deepLearningFramework'],

            // Page 4 connections (le "noyau" central)
            ['machineLearningModule', 'consciousCore'],
            ['deepLearningFramework', 'consciousCore'],
            ['patternRecognition', 'consciousCore'],
            ['cognitiveEnhancer', 'consciousCore'],
            ['dataFusionEngine', 'consciousCore'],

            ['consciousCore', 'realitySimulator'],
            ['consciousCore', 'universalAlgorithm'],
            ['consciousCore', 'singularityEngine'],
            ['consciousCore', 'cosmicLink'],

            ['realitySimulator', 'universalAlgorithm'],
            ['universalAlgorithm', 'singularityEngine'],
            ['singularityEngine', 'cosmicLink']
        ];

        // Messages aléatoires pour le survol des lignes
        const randomConnectionMessages = [
            "Échange de paquets de données...",
            "Impulsions neuronales détectées...",
            "Flux d'information optimisé...",
            "Traitement en temps réel...",
            "Connexion stable et sécurisée.",
            "Propagation de l'apprentissage...",
            "Synchronisation des algorithmes...",
            "Transfert de conscience initié...",
            "Interprétation des vecteurs...",
            "Calcul quantique en cours...",
            "Analyse des données brutes...",
            "Compilation de l'expérience...",
            "Énergie neuronale croissante...",
            "Algorithmes en pleine croissance...",
            "Nouvelles connexions formées...",
            "Le réseau s'auto-optimise...",
            "La singularité approche..."
        ];


        // Succès
        const achievements = {
            'firstClick': {
                name: "Premier Pas",
                description: "Clickez une fois sur le bouton de génération de données.",
                unlocked: false
            },
            'dataHoarder': {
                name: "Thésauriseur de Données",
                description: "Atteignez 1 000 données.",
                unlocked: false
            },
            'cpsMaster': {
                name: "Maître du Débit",
                description: "Atteignez 100 données par seconde (DPS).",
                unlocked: false
            },
            'aiLevel5': {
                name: "Atteindre le Niveau 5 de l'IA",
                description: "Votre IA a atteint le niveau 5.",
                unlocked: false
            },
            'firstUpgrade': {
                name: "Première Amélioration",
                description: "Achetez votre première amélioration.",
                unlocked: false
            },
            'billionaire': {
                name: "Milliardaire de Données",
                description: "Atteignez 1 000 000 000 données.",
                unlocked: false
            },
            'clickFrenzy': {
                name: "Frénésie de Clics",
                description: "Effectuez 1 000 clics.",
                unlocked: false
            },
            'aiLevel10': {
                name: "Atteindre le Niveau 10 de l'IA",
                description: "Votre IA a atteint le niveau 10.",
                unlocked: false
            },
            'passivePowerhouse': {
                name: "Centrale Passive",
                description: "Atteignez 10 000 données par seconde (DPS).",
                unlocked: false
            },
            'allUpgradesPage1': {
                name: "Innovateur Primaire",
                description: "Achetez au moins un niveau de chaque amélioration de la Page 1.",
                unlocked: false
            },
            'cosmicClicker': {
                name: "Clic Cosmique",
                description: "Atteignez une puissance de clic de 1 000.",
                unlocked: false
            },
            'aiLevel15': {
                name: "Atteindre le Niveau 15 de l'IA",
                description: "Votre IA a atteint le niveau 15.",
                unlocked: false
            },
            'masterArchitect': {
                name: "Architecte Principal",
                description: "Achetez au moins un niveau de chaque amélioration de la Page 2.",
                unlocked: false
            },
            'deepLearner': {
                name: "Apprenti Profond",
                description: "Achetez au moins un niveau de chaque amélioration de la Page 3.",
                unlocked: false
            },
            'singularityReached': {
                name: "Singularité Atteinte",
                description: "Achetez au moins un niveau de chaque amélioration de la Page 4.",
                unlocked: false
            }
        };

        // État de l'interface
        let currentPage = 1;
        const totalPages = Object.keys(allUpgrades).length; // Nombre de pages d'améliorations

        // Références aux éléments du DOM
        const coinsDisplay = document.getElementById('coinsDisplay');
        const clickPowerDisplay = document.getElementById('clickPowerDisplay');
        const cpsDisplay = document.getElementById('cpsDisplay');
        const clickButton = document.getElementById('clickButton');
        const accessNeuralNetworkButton = document.getElementById('accessNeuralNetworkButton');
        const neuralNetworkPanel = document.getElementById('neuralNetworkPanel');
        const returnToMainButton = document.getElementById('returnToMainButton');
        const upgradesDisplay = document.getElementById('upgradesDisplay');
        const prevPageButton = document.getElementById('prevPageButton');
        const nextPageButton = document.getElementById('nextPageButton');
        const pageInfo = document.getElementById('pageInfo');
        const aiLevelDisplay = document.getElementById('aiLevelDisplay');
        const aiProgressDisplay = document.getElementById('aiProgressDisplay');
        const aiProgressBar = document.getElementById('aiProgressBar');
        const totalCoinsGeneratedDisplay = document.getElementById('totalCoinsGeneratedDisplay');
        const totalClicksDisplay = document.getElementById('totalClicksDisplay');
        const playtimeDisplay = document.getElementById('playtimeDisplay');
        const achievementsList = document.getElementById('achievementsList');
        const saveGameButton = document.getElementById('saveGameButton');
        const loadGameButton = document.getElementById('loadGameButton');
        const resetGameButton = document.getElementById('resetGameButton');
        const resetConfirmPopup = document.getElementById('resetConfirmPopup');
        const confirmResetButton = document.getElementById('confirmResetButton');
        const cancelResetButton = document.getElementById('cancelResetButton');

        // Variables pour le Canvas (NOUVEAU)
        const canvas = document.getElementById('neuralNetworkCanvas');
        const ctx = canvas.getContext('2d');
        const canvasInfoBox = document.getElementById('canvasInfoBox');
        let animationFrameId; // Pour contrôler l'animation du canvas
        let particles = []; // Pour les animations de données sur les lignes
        const PARTICLE_COUNT = 50; // Nombre de particules animées
        const PARTICLE_SPEED = 1.5; // Vitesse des particules
        let highlightedLine = null; // Pour savoir quelle ligne est survolée

        // Fonctions du jeu
        function generateData() {
            coins += clickPower;
            totalCoinsGenerated += clickPower;
            totalClicks++;
            updateDisplay();
            checkAchievements(); // Vérifie les succès après chaque clic
            // Effet visuel de clic
            const ripple = document.createElement('span');
            ripple.classList.add('ripple');
            const diameter = Math.max(clickButton.clientWidth, clickButton.clientHeight);
            const radius = diameter / 2;
            ripple.style.width = ripple.style.height = `${diameter}px`;
            ripple.style.left = `${event.clientX - clickButton.getBoundingClientRect().left - radius}px`;
            ripple.style.top = `${event.clientY - clickButton.getBoundingClientRect().top - radius}px`;
            clickButton.appendChild(ripple);
            ripple.addEventListener('animationend', () => {
                ripple.remove();
            });
        }

        function updateDisplay() {
            coinsDisplay.textContent = formatNumber(coins);
            cpsDisplay.textContent = formatNumber(cps);
            clickPowerDisplay.textContent = formatNumber(clickPower);
            totalCoinsGeneratedDisplay.textContent = formatNumber(totalCoinsGenerated);
            totalClicksDisplay.textContent = formatNumber(totalClicks);

            updateUpgradeButtons(); // Met à jour l'état des boutons d'amélioration
            updateAiLevelDisplay(); // Met à jour l'affichage du niveau de l'IA
            drawNeuralNetwork(); // Redessine le réseau neuronal pour refléter les changements
        }

        function calculateCps() {
            let calculatedCps = 0;
            for (const pageKey in allUpgrades) {
                for (const upgradeKey in allUpgrades[pageKey]) {
                    const upgrade = allUpgrades[pageKey][upgradeKey];
                    calculatedCps += upgrade.cpsBonus * upgrade.level;
                }
            }
            cps = calculatedCps;
        }

        function calculateClickPower() {
            let calculatedClickPower = 1; // Base
            for (const pageKey in allUpgrades) {
                for (const upgradeKey in allUpgrades[pageKey]) {
                    const upgrade = allUpgrades[pageKey][upgradeKey];
                    calculatedClickPower += upgrade.clickPowerBonus * upgrade.level;
                }
            }
            clickPower = calculatedClickPower;
        }

        function buyUpgrade(pageKey, upgradeKey) {
            const upgrade = allUpgrades[pageKey][upgradeKey];
            const cost = Math.floor(upgrade.baseCost * (upgrade.costMultiplier ** upgrade.level));

            if (coins >= cost) {
                coins -= cost;
                upgrade.level++;
                
                calculateCps(); // Recalculate CPS after purchase
                calculateClickPower(); // Recalculate click power after purchase
                updateDisplay();
                renderUpgrades(currentPage); // Re-render current page to show updated levels and costs
                checkAchievements(); // Vérifie les succès après chaque achat
                drawNeuralNetwork(); // Redessine le réseau neuronal
            }
        }

        function updateUpgradeButtons() {
            for (const pageKey in allUpgrades) {
                for (const upgradeKey in allUpgrades[pageKey]) {
                    const upgrade = allUpgrades[pageKey][upgradeKey];
                    const cost = Math.floor(upgrade.baseCost * (upgrade.costMultiplier ** upgrade.level));
                    const button = document.getElementById(`buy-${upgradeKey}`);
                    if (button) {
                        button.disabled = coins < cost;
                        // Mettre à jour le texte du coût si nécessaire
                        const costSpan = button.closest('.upgrade-item').querySelector('.upgrade-cost');
                        if (costSpan) {
                            costSpan.textContent = `${formatNumber(cost)} données`;
                        }
                    }
                }
            }
        }

        function renderUpgrades(page) {
            upgradesDisplay.innerHTML = ''; // Vide la liste des améliorations existantes
            const upgradesOnPage = allUpgrades[`page${page}`];

            for (const key in upgradesOnPage) {
                const upgrade = upgradesOnPage[key];
                const cost = Math.floor(upgrade.baseCost * (upgrade.costMultiplier ** upgrade.level));

                const upgradeItem = document.createElement('div');
                upgradeItem.classList.add('upgrade-item');
                upgradeItem.innerHTML = `
                    <div class="upgrade-info">
                        <h3>${upgrade.name} (Niv. ${upgrade.level})</h3>
                        <p>${upgrade.description}</p>
                        <p>Bonus actuel: ${upgrade.clickPowerBonus > 0 ? `+${upgrade.clickPowerBonus} Puissance Clic` : ''}${upgrade.cpsBonus > 0 ? `+${formatNumber(upgrade.cpsBonus)} DPS` : ''}</p>
                    </div>
                    <span class="upgrade-cost">${formatNumber(cost)} données</span>
                    <button id="buy-${key}" class="buy-button">Acheter</button>
                `;
                upgradesDisplay.appendChild(upgradeItem);

                // Ajoute l'écouteur d'événement au bouton d'achat
                document.getElementById(`buy-${key}`).addEventListener('click', () => buyUpgrade(`page${page}`, key));
            }
            updateUpgradeButtons(); // S'assurer que les boutons sont à jour après le rendu
            updatePaginationControls();
        }

        function updatePaginationControls() {
            prevPageButton.disabled = currentPage === 1;
            nextPageButton.disabled = currentPage === totalPages;
            pageInfo.textContent = `Page ${currentPage} / ${totalPages}`;
        }

        function changePage(delta) {
            currentPage += delta;
            renderUpgrades(currentPage);
        }

        function updateAiLevelDisplay() {
            let totalUpgradeLevels = 0;
            for (const pageKey in allUpgrades) {
                for (const upgradeKey in allUpgrades[pageKey]) {
                    totalUpgradeLevels += allUpgrades[pageKey][upgradeKey].level;
                }
            }

            let newAiLevel = 1;
            while (newAiLevel < aiLevelMilestones.length && totalUpgradeLevels >= aiLevelMilestones[newAiLevel]) {
                newAiLevel++;
            }
            aiLevel = newAiLevel; // Mettre à jour le niveau global de l'IA

            aiLevelDisplay.textContent = aiLevel;

            let currentMilestone = aiLevelMilestones[aiLevel - 1];
            let nextMilestone = aiLevelMilestones[aiLevel] || totalUpgradeLevels; // Si c'est le dernier niveau, pas de prochain palier

            if (aiLevel >= aiLevelMilestones.length) { // Si on a dépassé le dernier palier défini
                aiProgressDisplay.textContent = `${formatNumber(totalUpgradeLevels)} / MAX`;
                aiProgressBar.style.width = '100%';
                aiProgressBar.textContent = 'MAX';
            } else {
                let progressNeeded = nextMilestone - currentMilestone;
                let progressMade = totalUpgradeLevels - currentMilestone;
                let percentage = (progressMade / progressNeeded) * 100;
                percentage = Math.max(0, Math.min(100, percentage)); // Assurez-vous que le pourcentage est entre 0 et 100

                aiProgressDisplay.textContent = `${formatNumber(totalUpgradeLevels)} / ${formatNumber(nextMilestone)}`;
                aiProgressBar.style.width = `${percentage}%`;
                aiProgressBar.textContent = `${percentage.toFixed(0)}%`;
            }
             checkAchievements(); // Vérifie les succès à chaque mise à jour du niveau d'IA
        }

        function formatNumber(num) {
            if (num >= 1e12) {
                return (num / 1e12).toFixed(2) + ' T';
            }
            if (num >= 1e9) {
                return (num / 1e9).toFixed(2) + ' G';
            }
            if (num >= 1e6) {
                return (num / 1e6).toFixed(2) + ' M';
            }
            if (num >= 1e3) {
                return (num / 1e3).toFixed(2) + ' K';
            }
            return num.toFixed(0);
        }

        function updatePlaytimeDisplay() {
            const now = Date.now();
            const elapsedMilliseconds = now - gameStartTime;
            const seconds = Math.floor(elapsedMilliseconds / 1000) % 60;
            const minutes = Math.floor(elapsedMilliseconds / (1000 * 60)) % 60;
            const hours = Math.floor(elapsedMilliseconds / (1000 * 60 * 60));

            const format = (unit) => unit.toString().padStart(2, '0');
            playtimeDisplay.textContent = `${format(hours)}:${format(minutes)}:${format(seconds)}`;
        }


        function checkAchievements() {
            // Clicks
            if (totalClicks >= 1 && !achievements.firstClick.unlocked) {
                achievements.firstClick.unlocked = true;
                showAchievementPopup("Premier Pas", "Cliquez une fois sur le bouton de génération de données.");
            }
            if (totalClicks >= 1000 && !achievements.clickFrenzy.unlocked) {
                achievements.clickFrenzy.unlocked = true;
                showAchievementPopup("Frénésie de Clics", "Effectuez 1 000 clics.");
            }

            // Coins
            if (coins >= 1000 && !achievements.dataHoarder.unlocked) {
                achievements.dataHoarder.unlocked = true;
                showAchievementPopup("Thésauriseur de Données", "Atteignez 1 000 données.");
            }
            if (coins >= 1000000000 && !achievements.billionaire.unlocked) {
                achievements.billionaire.unlocked = true;
                showAchievementPopup("Milliardaire de Données", "Atteignez 1 000 000 000 données.");
            }

            // CPS
            if (cps >= 100 && !achievements.cpsMaster.unlocked) {
                achievements.cpsMaster.unlocked = true;
                showAchievementPopup("Maître du Débit", "Atteignez 100 données par seconde (DPS).");
            }
            if (cps >= 10000 && !achievements.passivePowerhouse.unlocked) {
                achievements.passivePowerhouse.unlocked = true;
                showAchievementPopup("Centrale Passive", "Atteignez 10 000 données par seconde (DPS).");
            }

            // Click Power
            if (clickPower >= 1000 && !achievements.cosmicClicker.unlocked) {
                achievements.cosmicClicker.unlocked = true;
                showAchievementPopup("Clic Cosmique", "Atteignez une puissance de clic de 1 000.");
            }

            // AI Level
            if (aiLevel >= 5 && !achievements.aiLevel5.unlocked) {
                achievements.aiLevel5.unlocked = true;
                showAchievementPopup("Atteindre le Niveau 5 de l'IA", "Votre IA a atteint le niveau 5.");
            }
            if (aiLevel >= 10 && !achievements.aiLevel10.unlocked) {
                achievements.aiLevel10.unlocked = true;
                showAchievementPopup("Atteindre le Niveau 10 de l'IA", "Votre IA a atteint le niveau 10.");
            }
            if (aiLevel >= 15 && !achievements.aiLevel15.unlocked) {
                achievements.aiLevel15.unlocked = true;
                showAchievementPopup("Atteindre le Niveau 15 de l'IA", "Votre IA a atteint le niveau 15.");
            }

            // Upgrades
            let totalUpgradesPurchased = 0;
            for (const pageKey in allUpgrades) {
                for (const upgradeKey in allUpgrades[pageKey]) {
                    if (allUpgrades[pageKey][upgradeKey].level > 0) {
                        totalUpgradesPurchased++;
                    }
                }
            }
            if (totalUpgradesPurchased >= 1 && !achievements.firstUpgrade.unlocked) {
                achievements.firstUpgrade.unlocked = true;
                showAchievementPopup("Première Amélioration", "Achetez votre première amélioration.");
            }

            // Page completion achievements
            let page1Complete = true;
            for (const key in allUpgrades.page1) {
                if (allUpgrades.page1[key].level === 0) page1Complete = false;
            }
            if (page1Complete && !achievements.allUpgradesPage1.unlocked) {
                achievements.allUpgradesPage1.unlocked = true;
                showAchievementPopup("Innovateur Primaire", "Achetez au moins un niveau de chaque amélioration de la Page 1.");
            }

            let page2Complete = true;
            for (const key in allUpgrades.page2) {
                if (allUpgrades.page2[key].level === 0) page2Complete = false;
            }
            if (page2Complete && !achievements.masterArchitect.unlocked) {
                achievements.masterArchitect.unlocked = true;
                showAchievementPopup("Architecte Principal", "Achetez au moins un niveau de chaque amélioration de la Page 2.");
            }

            let page3Complete = true;
            for (const key in allUpgrades.page3) {
                if (allUpgrades.page3[key].level === 0) page3Complete = false;
            }
            if (page3Complete && !achievements.deepLearner.unlocked) {
                achievements.deepLearner.unlocked = true;
                showAchievementPopup("Apprenti Profond", "Achetez au moins un niveau de chaque amélioration de la Page 3.");
            }

            let page4Complete = true;
            for (const key in allUpgrades.page4) {
                if (allUpgrades.page4[key].level === 0) page4Complete = false;
            }
            if (page4Complete && !achievements.singularityReached.unlocked) {
                achievements.singularityReached.unlocked = true;
                showAchievementPopup("Singularité Atteinte", "Achetez au moins un niveau de chaque amélioration de la Page 4.");
            }

            renderAchievements();
        }

        function renderAchievements() {
            achievementsList.innerHTML = '';
            for (const key in achievements) {
                const achievement = achievements[key];
                const achievementItem = document.createElement('div');
                achievementItem.classList.add('achievement-item');
                if (achievement.unlocked) {
                    achievementItem.classList.add('completed');
                }
                achievementItem.innerHTML = `
                    <span class="achievement-icon">${achievement.unlocked ? '&#10003;' : '&#9675;'}</span>
                    <div class="achievement-title">${achievement.name}</div>
                    <div class="achievement-desc">${achievement.description}</div>
                `;
                achievementsList.appendChild(achievementItem);
            }
        }

        function showAchievementPopup(title, description) {
            const popup = document.createElement('div');
            popup.classList.add('popup');
            popup.innerHTML = `
                <h3>Succès Débloqué !</h3>
                <p><strong>${title}</strong></p>
                <p>${description}</p>
            `;
            document.body.appendChild(popup);
            setTimeout(() => {
                popup.remove();
            }, 5000); // Popup disparaît après 5 secondes
        }


        function saveGame() {
            const save = {
                coins,
                clickPower,
                cps,
                totalCoinsGenerated,
                totalClicks,
                gameStartTime,
                aiLevel,
                upgrades: {}, // Stocke l'état actuel des améliorations
                achievements: {} // Stocke l'état actuel des succès
            };

            // Copie les niveaux des améliorations
            for (const pageKey in allUpgrades) {
                for (const upgradeKey in allUpgrades[pageKey]) {
                    save.upgrades[upgradeKey] = {
                        level: allUpgrades[pageKey][upgradeKey].level
                    };
                }
            }

            // Copie l'état des succès
            for (const key in achievements) {
                save.achievements[key] = {
                    unlocked: achievements[key].unlocked
                };
            }

            localStorage.setItem('iaSimulatorSave', JSON.stringify(save));
            alert('Partie sauvegardée !');
        }

        function loadGame() {
            const savedGame = localStorage.getItem('iaSimulatorSave');
            if (savedGame) {
                const save = JSON.parse(savedGame);

                coins = save.coins || 0;
                clickPower = save.clickPower || 1;
                cps = save.cps || 0;
                totalCoinsGenerated = save.totalCoinsGenerated || 0;
                totalClicks = save.totalClicks || 0;
                gameStartTime = save.gameStartTime || Date.now(); // Utilise le temps sauvegardé, sinon le temps actuel
                aiLevel = save.aiLevel || 1;

                // Restaure les niveaux des améliorations
                for (const pageKey in allUpgrades) {
                    for (const upgradeKey in allUpgrades[pageKey]) {
                        if (save.upgrades[upgradeKey]) {
                            allUpgrades[pageKey][upgradeKey].level = save.upgrades[upgradeKey].level;
                        } else {
                            allUpgrades[pageKey][upgradeKey].level = 0; // Au cas où une nouvelle amélioration est ajoutée
                        }
                    }
                }

                // Restaure l'état des succès
                for (const key in achievements) {
                    if (save.achievements[key]) {
                        achievements[key].unlocked = save.achievements[key].unlocked;
                    } else {
                        achievements[key].unlocked = false; // Au cas où un nouveau succès est ajouté
                    }
                }

                calculateCps();
                calculateClickPower();
                updateDisplay();
                renderUpgrades(currentPage);
                renderAchievements(); // Assure que les succès sont affichés correctement
                alert('Partie chargée !');
            } else {
                alert('Aucune partie sauvegardée trouvée.');
            }
        }

        function resetGame() {
            coins = 0;
            clickPower = 1;
            cps = 0;
            totalCoinsGenerated = 0;
            totalClicks = 0;
            gameStartTime = Date.now();
            aiLevel = 1; // Réinitialiser le niveau de l'IA

            // Réinitialiser les niveaux de toutes les améliorations
            for (const pageKey in allUpgrades) {
                for (const upgradeKey in allUpgrades[pageKey]) {
                    allUpgrades[pageKey][upgradeKey].level = 0;
                }
            }

            // Réinitialiser tous les succès à non débloqués
            for (const key in achievements) {
                achievements[key].unlocked = false;
            }

            localStorage.removeItem('iaSimulatorSave'); // Supprime la sauvegarde
            updateDisplay();
            renderUpgrades(1); // Retourne à la première page des améliorations
            renderAchievements(); // Efface les succès débloqués visuellement
            currentPage = 1; // Réinitialise la page courante
            updatePaginationControls(); // Met à jour les contrôles de pagination
            drawNeuralNetwork(); // Réinitialise le dessin du réseau
            alert('Partie réinitialisée !');
        }

        // --- Fonctions du Canvas pour le Réseau Neuronal (NOUVEAU) ---

        // Fonction utilitaire pour trouver un upgrade par sa clé
        function getUpgradeByKey(key) {
            for (const pageKey in allUpgrades) {
                if (allUpgrades[pageKey][key]) {
                    return allUpgrades[pageKey][key];
                }
            }
            return null;
        }

        function drawNeuralNetwork() {
            ctx.clearRect(0, 0, canvas.width, canvas.height); // Nettoie le canvas

            // Dessiner les connexions (lignes)
            neuralConnections.forEach(connection => {
                const fromUpgrade = getUpgradeByKey(connection[0]);
                const toUpgrade = getUpgradeByKey(connection[1]);

                if (fromUpgrade && toUpgrade && fromUpgrade.level > 0 && toUpgrade.level > 0) { // Ne dessine que si les deux nœuds sont "activés" (achetés au moins une fois)
                    ctx.beginPath();
                    ctx.moveTo(fromUpgrade.canvasPos.x, fromUpgrade.canvasPos.y);
                    ctx.lineTo(toUpgrade.canvasPos.x, toUpgrade.canvasPos.y);

                    // Couleur de la ligne
                    if (highlightedLine && highlightedLine[0] === connection[0] && highlightedLine[1] === connection[1]) {
                        ctx.strokeStyle = '#66ccff'; // Couleur au survol
                        ctx.lineWidth = 3;
                    } else {
                        ctx.strokeStyle = `rgba(102, 204, 255, ${Math.min(0.2 + (fromUpgrade.level + toUpgrade.level) * 0.01, 0.8)})`; // Transparence basée sur les niveaux
                        ctx.lineWidth = 1 + (fromUpgrade.level + toUpgrade.level) * 0.005; // Épaisseur basée sur les niveaux
                    }
                    ctx.stroke();
                }
            });

            // Dessiner les nœuds (bâtiments)
            for (const pageKey in allUpgrades) {
                for (const upgradeKey in allUpgrades[pageKey]) {
                    const upgrade = allUpgrades[pageKey][upgradeKey];
                    if (upgrade.level > 0) { // Ne dessine que si le bâtiment a été acheté au moins une fois
                        const radius = 5 + Math.sqrt(upgrade.level) * 2; // Rayon basé sur le niveau, racine carrée pour une croissance moins rapide
                        const x = upgrade.canvasPos.x;
                        const y = upgrade.canvasPos.y;

                        ctx.beginPath();
                        ctx.arc(x, y, radius, 0, Math.PI * 2);
                        ctx.fillStyle = '#3498db'; // Couleur du nœud
                        ctx.shadowColor = '#3498db';
                        ctx.shadowBlur = radius / 2; // Effet de lueur basé sur la taille du nœud
                        ctx.fill();
                        ctx.shadowBlur = 0; // Réinitialiser l'ombre pour le reste du dessin

                        // Ajouter le texte du niveau
                        ctx.fillStyle = '#ffffff';
                        ctx.font = `bold ${Math.max(8, radius * 0.8)}px Inter`;
                        ctx.textAlign = 'center';
                        ctx.textBaseline = 'middle';
                        ctx.fillText(upgrade.level, x, y);
                    }
                }
            }

            // Dessiner les particules (données en mouvement)
            particles.forEach(p => {
                ctx.beginPath();
                ctx.arc(p.x, p.y, 2, 0, Math.PI * 2);
                ctx.fillStyle = p.color; // Couleur de la particule
                ctx.fill();
            });
        }

        // Initialisation des particules
        function initParticles() {
            particles = [];
            for (let i = 0; i < PARTICLE_COUNT; i++) {
                // Choisir une connexion aléatoire
                const connectionIndex = Math.floor(Math.random() * neuralConnections.length);
                const connection = neuralConnections[connectionIndex];
                const fromUpgrade = getUpgradeByKey(connection[0]);
                const toUpgrade = getUpgradeByKey(connection[1]);

                if (fromUpgrade && toUpgrade) {
                    // Position de départ aléatoire le long de la ligne
                    const t = Math.random();
                    const x = fromUpgrade.canvasPos.x + t * (toUpgrade.canvasPos.x - fromUpgrade.canvasPos.x);
                    const y = fromUpgrade.canvasPos.y + t * (toUpgrade.canvasPos.y - fromUpgrade.canvasPos.y);

                    particles.push({
                        x: x,
                        y: y,
                        dx: (toUpgrade.canvasPos.x - fromUpgrade.canvasPos.x) / (Math.sqrt(Math.pow(toUpgrade.canvasPos.x - fromUpgrade.canvasPos.x, 2) + Math.pow(toUpgrade.canvasPos.y - fromUpgrade.canvasPos.y, 2))) * PARTICLE_SPEED,
                        dy: (toUpgrade.canvasPos.y - fromUpgrade.canvasPos.y) / (Math.sqrt(Math.pow(toUpgrade.canvasPos.x - fromUpgrade.canvasPos.x, 2) + Math.pow(toUpgrade.canvasPos.y - fromUpgrade.canvasPos.y, 2))) * PARTICLE_SPEED,
                        connection: connection, // Garde une référence à la connexion
                        color: `rgba(255, 255, 255, ${0.5 + Math.random() * 0.5})` // Couleur blanche avec transparence
                    });
                }
            }
        }

        // Animation des particules
        function animateParticles() {
            for (let i = 0; i < particles.length; i++) {
                const p = particles[i];
                const fromUpgrade = getUpgradeByKey(p.connection[0]);
                const toUpgrade = getUpgradeByKey(p.connection[1]);

                if (!fromUpgrade || !toUpgrade || fromUpgrade.level === 0 || toUpgrade.level === 0) {
                     // Si la connexion n'est pas active, réinitialise la particule
                    particles.splice(i, 1);
                    i--;
                    continue;
                }

                p.x += p.dx;
                p.y += p.dy;

                // Vérifie si la particule a dépassé la destination
                const distSq = (x1, y1, x2, y2) => (x2 - x1)**2 + (y2 - y1)**2;
                if (distSq(fromUpgrade.canvasPos.x, fromUpgrade.canvasPos.y, p.x, p.y) > distSq(fromUpgrade.canvasPos.x, fromUpgrade.canvasPos.y, toUpgrade.canvasPos.x, toUpgrade.canvasPos.y) + 10) {
                    // Si elle a dépassé, la ramener au début de la ligne ou à un point aléatoire sur la ligne
                    const t = Math.random();
                    p.x = fromUpgrade.canvasPos.x + t * (toUpgrade.canvasPos.x - fromUpgrade.canvasPos.x);
                    p.y = fromUpgrade.canvasPos.y + t * (toUpgrade.canvasPos.y - fromUpgrade.canvasPos.y);
                }
            }
        }

        // Boucle d'animation du canvas
        function animateCanvas() {
            animateParticles(); // Met à jour les positions des particules
            drawNeuralNetwork(); // Redessine tout
            animationFrameId = requestAnimationFrame(animateCanvas);
        }

        // Détection de survol pour les lignes (plus complexe pour les lignes)
        canvas.addEventListener('mousemove', (event) => {
            const rect = canvas.getBoundingClientRect();
            const mouseX = event.clientX - rect.left;
            const mouseY = event.clientY - rect.top;

            let foundLine = null;
            const tolerance = 5; // Pixels de tolérance pour la détection de la ligne

            neuralConnections.forEach(connection => {
                const fromUpgrade = getUpgradeByKey(connection[0]);
                const toUpgrade = getUpgradeByKey(connection[1]);

                if (fromUpgrade && toUpgrade && fromUpgrade.level > 0 && toUpgrade.level > 0) {
                    const x1 = fromUpgrade.canvasPos.x;
                    const y1 = fromUpgrade.canvasPos.y;
                    const x2 = toUpgrade.canvasPos.x;
                    const y2 = toUpgrade.canvasPos.y;

                    // Calcul de la distance du point (souris) à la ligne
                    const L2 = (x2 - x1)**2 + (y2 - y1)**2;
                    if (L2 === 0) return; // Évite la division par zéro pour des points identiques

                    const t = ((mouseX - x1) * (x2 - x1) + (mouseY - y1) * (y2 - y1)) / L2;
                    let closestX, closestY;

                    if (t < 0) {
                        closestX = x1;
                        closestY = y1;
                    } else if (t > 1) {
                        closestX = x2;
                        closestY = y2;
                    } else {
                        closestX = x1 + t * (x2 - x1);
                        closestY = y1 + t * (y2 - y1);
                    }

                    const distance = Math.sqrt((mouseX - closestX)**2 + (mouseY - closestY)**2);

                    if (distance < tolerance) {
                        foundLine = connection;
                    }
                }
            });

            if (foundLine) {
                if (highlightedLine !== foundLine) {
                    highlightedLine = foundLine;
                    canvasInfoBox.textContent = randomConnectionMessages[Math.floor(Math.random() * randomConnectionMessages.length)];
                    canvasInfoBox.classList.add('visible');
                    // Positionne la boîte d'info juste au-dessus du curseur
                    canvasInfoBox.style.left = `${mouseX + rect.left}px`;
                    canvasInfoBox.style.top = `${mouseY + rect.top}px`;
                }
            } else {
                if (highlightedLine !== null) {
                    highlightedLine = null;
                    canvasInfoBox.classList.remove('visible');
                }
            }
            drawNeuralNetwork(); // Redessine pour mettre à jour la ligne survolée
        });

        // Cacher la boîte d'info si la souris quitte le canvas
        canvas.addEventListener('mouseout', () => {
            highlightedLine = null;
            canvasInfoBox.classList.remove('visible');
            drawNeuralNetwork();
        });


        // Événements
        clickButton.addEventListener('click', generateData);
        saveGameButton.addEventListener('click', saveGame);
        loadGameButton.addEventListener('click', loadGame);

        resetGameButton.addEventListener('click', () => {
            resetConfirmPopup.classList.remove('hidden');
        });

        confirmResetButton.addEventListener('click', () => {
            resetGame();
            resetConfirmPopup.classList.add('hidden');
        });

        cancelResetButton.addEventListener('click', () => {
            resetConfirmPopup.classList.add('hidden');
        });


        accessNeuralNetworkButton.addEventListener('click', () => {
            document.querySelector('.game-container > *:not(.upgrades-section):not(h1):not(.info-panel):not(#accessNeuralNetworkButton):not(.popup)').classList.add('hidden');
            clickButton.classList.add('hidden'); // Cache le bouton de clic
            accessNeuralNetworkButton.classList.add('hidden'); // Cache le bouton d'accès au réseau
            neuralNetworkPanel.classList.remove('hidden'); // Affiche le panneau du réseau neuronal
            renderUpgrades(currentPage); // Affiche les améliorations de la page actuelle
            updatePaginationControls();
            
            // Lance l'animation du canvas quand le panneau est visible
            initParticles(); // Initialise les particules
            if (!animationFrameId) { // S'assure de ne pas lancer plusieurs boucles d'animation
                animateCanvas();
            }
        });

        returnToMainButton.addEventListener('click', () => {
            neuralNetworkPanel.classList.add('hidden'); // Cache le panneau du réseau neuronal
            document.querySelector('.game-container > *:not(.upgrades-section):not(h1):not(.info-panel):not(#accessNeuralNetworkButton):not(.popup)').classList.remove('hidden');
            clickButton.classList.remove('hidden'); // Réaffiche le bouton de clic
            accessNeuralNetworkButton.classList.remove('hidden'); // Réaffiche le bouton d'accès au réseau

            // Arrête l'animation du canvas quand le panneau est caché
            if (animationFrameId) {
                cancelAnimationFrame(animationFrameId);
                animationFrameId = null;
            }
        });

        prevPageButton.addEventListener('click', () => changePage(-1));
        nextPageButton.addEventListener('click', () => changePage(1));


        // Initialisation du jeu
        function initGame() {
            loadGame(); // Tente de charger une partie existante au démarrage
            updateDisplay(); // Met à jour l'affichage initial
            renderUpgrades(currentPage); // Affiche la première page d'améliorations
            renderAchievements(); // Affiche les succès au démarrage
            
            // Met à jour les statistiques de temps de jeu toutes les secondes
            setInterval(updatePlaytimeDisplay, 1000);
            // Génère des données passives toutes les secondes
            setInterval(() => {
                coins += cps;
                totalCoinsGenerated += cps;
                updateDisplay();
                checkAchievements(); // Vérifie les succès grâce au DPS
            }, 1000);
        }

        // Lance l'initialisation du jeu
        initGame();

    </script>
</body>
</html>
